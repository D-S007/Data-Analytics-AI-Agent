import pandas as pd
import tempfile
import os
from ydata_profiling import ProfileReport
from typing import Optional

class DataProfiler:
    """Generate comprehensive data profiling reports using ydata-profiling"""
    
    def __init__(self):
        self.report_config = {
            "title": "Data Analytics AI Agent - Data Profile Report",
            "dataset": {
                "description": "Automated data profiling report generated by AI Agent"
            },
            "variables": {
                "descriptions": {}
            },
            "correlations": {
                "pearson": {"calculate": True},
                "spearman": {"calculate": True},
                "kendall": {"calculate": False},
                "phi_k": {"calculate": False},
                "cramers": {"calculate": False}
            },
            "missing_diagrams": {
                "matrix": True,
                "bar": True,
                "heatmap": True,
                "dendrogram": True
            },
            "samples": {"head": 10, "tail": 10},
            "duplicates": {"head": 10, "key": "# duplicates"},
        }
    
    def generate_profile_report(self, data: pd.DataFrame, 
                              title: Optional[str] = None,
                              output_path: Optional[str] = None) -> str:
        """Generate a comprehensive profile report"""
        
        try:
            # Set custom title if provided
            config = self.report_config.copy()
            if title:
                config["title"] = title
            
            # Create the profile report
            profile = ProfileReport(
                data, 
                **config,
                minimal=False,  # Full report
                explorative=True  # Include advanced analysis
            )
            
            # Set output path
            if output_path is None:
                # Create temporary file
                temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.html')
                output_path = temp_file.name
                temp_file.close()
            
            # Generate the report
            profile.to_file(output_path)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Failed to generate profile report: {str(e)}")
    
    def generate_minimal_report(self, data: pd.DataFrame, 
                               output_path: Optional[str] = None) -> str:
        """Generate a minimal profile report for faster processing"""
        
        try:
            # Minimal configuration for faster processing
            minimal_config = {
                "title": "Quick Data Profile Report",
                "minimal": True,
                "samples": {"head": 5, "tail": 5},
                "correlations": {
                    "pearson": {"calculate": True},
                    "spearman": {"calculate": False},
                    "kendall": {"calculate": False}
                },
                "missing_diagrams": {
                    "matrix": False,
                    "bar": True,
                    "heatmap": False,
                    "dendrogram": False
                },
                "interactions": {"continuous": False, "targets": []},
                "duplicates": {"head": 5}
            }
            
            profile = ProfileReport(data, **minimal_config)
            
            if output_path is None:
                temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.html')
                output_path = temp_file.name
                temp_file.close()
            
            profile.to_file(output_path)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Failed to generate minimal report: {str(e)}")
    
    def get_basic_statistics(self, data: pd.DataFrame) -> dict:
        """Get basic statistics without generating full report"""
        
        try:
            stats = {
                "dataset_info": {
                    "n_rows": len(data),
                    "n_columns": len(data.columns),
                    "memory_size": data.memory_usage(deep=True).sum(),
                    "missing_cells": data.isnull().sum().sum(),
                    "missing_cells_perc": (data.isnull().sum().sum() / (len(data) * len(data.columns))) * 100,
                    "duplicate_rows": data.duplicated().sum(),
                    "duplicate_rows_perc": (data.duplicated().sum() / len(data)) * 100
                },
                "column_types": {
                    "numeric": len(data.select_dtypes(include=['number']).columns),
                    "categorical": len(data.select_dtypes(include=['object', 'category']).columns),
                    "datetime": len(data.select_dtypes(include=['datetime']).columns),
                    "boolean": len(data.select_dtypes(include=['bool']).columns)
                },
                "column_details": {}
            }
            
            # Get details for each column
            for col in data.columns:
                col_stats = {
                    "dtype": str(data[col].dtype),
                    "missing_count": data[col].isnull().sum(),
                    "missing_perc": (data[col].isnull().sum() / len(data)) * 100,
                    "unique_count": data[col].nunique(),
                    "unique_perc": (data[col].nunique() / len(data)) * 100
                }
                
                # Add type-specific statistics
                if pd.api.types.is_numeric_dtype(data[col]):
                    col_stats.update({
                        "mean": data[col].mean(),
                        "std": data[col].std(),
                        "min": data[col].min(),
                        "max": data[col].max(),
                        "median": data[col].median()
                    })
                elif pd.api.types.is_string_dtype(data[col]) or data[col].dtype == 'object':
                    col_stats.update({
                        "max_length": data[col].astype(str).str.len().max() if len(data) > 0 else 0,
                        "min_length": data[col].astype(str).str.len().min() if len(data) > 0 else 0,
                        "avg_length": data[col].astype(str).str.len().mean() if len(data) > 0 else 0
                    })
                
                stats["column_details"][col] = col_stats
            
            return stats
            
        except Exception as e:
            raise Exception(f"Failed to generate basic statistics: {str(e)}")
    
    def generate_column_report(self, data: pd.DataFrame, column_name: str) -> dict:
        """Generate detailed report for a specific column"""
        
        if column_name not in data.columns:
            raise ValueError(f"Column '{column_name}' not found in dataset")
        
        try:
            col_data = data[column_name]
            
            report = {
                "column_name": column_name,
                "data_type": str(col_data.dtype),
                "total_count": len(col_data),
                "missing_count": col_data.isnull().sum(),
                "missing_percentage": (col_data.isnull().sum() / len(col_data)) * 100,
                "unique_count": col_data.nunique(),
                "unique_percentage": (col_data.nunique() / len(col_data)) * 100
            }
            
            # Non-null data for analysis
            clean_data = col_data.dropna()
            
            if pd.api.types.is_numeric_dtype(col_data):
                # Numeric column analysis
                report.update({
                    "statistics": {
                        "mean": clean_data.mean(),
                        "median": clean_data.median(),
                        "mode": clean_data.mode().iloc[0] if len(clean_data.mode()) > 0 else None,
                        "std": clean_data.std(),
                        "var": clean_data.var(),
                        "min": clean_data.min(),
                        "max": clean_data.max(),
                        "range": clean_data.max() - clean_data.min(),
                        "q25": clean_data.quantile(0.25),
                        "q75": clean_data.quantile(0.75),
                        "iqr": clean_data.quantile(0.75) - clean_data.quantile(0.25)
                    },
                    "outliers": self._detect_outliers(clean_data),
                    "distribution": {
                        "skewness": clean_data.skew(),
                        "kurtosis": clean_data.kurtosis()
                    }
                })
                
            elif pd.api.types.is_string_dtype(col_data) or col_data.dtype == 'object':
                # Text column analysis
                text_lengths = clean_data.astype(str).str.len()
                value_counts = clean_data.value_counts().head(10)
                
                report.update({
                    "text_analysis": {
                        "max_length": text_lengths.max(),
                        "min_length": text_lengths.min(),
                        "avg_length": text_lengths.mean(),
                        "total_characters": text_lengths.sum()
                    },
                    "top_values": value_counts.to_dict(),
                    "pattern_analysis": self._analyze_text_patterns(clean_data)
                })
                
            elif pd.api.types.is_datetime64_any_dtype(col_data):
                # DateTime column analysis
                report.update({
                    "datetime_analysis": {
                        "min_date": clean_data.min(),
                        "max_date": clean_data.max(),
                        "date_range": (clean_data.max() - clean_data.min()).days,
                        "most_common_year": clean_data.dt.year.mode().iloc[0] if len(clean_data) > 0 else None,
                        "most_common_month": clean_data.dt.month.mode().iloc[0] if len(clean_data) > 0 else None,
                        "most_common_day": clean_data.dt.day.mode().iloc[0] if len(clean_data) > 0 else None
                    }
                })
            
            return report
            
        except Exception as e:
            raise Exception(f"Failed to generate column report: {str(e)}")
    
    def _detect_outliers(self, data: pd.Series) -> dict:
        """Detect outliers using IQR method"""
        
        try:
            Q1 = data.quantile(0.25)
            Q3 = data.quantile(0.75)
            IQR = Q3 - Q1
            
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            
            outliers = data[(data < lower_bound) | (data > upper_bound)]
            
            return {
                "count": len(outliers),
                "percentage": (len(outliers) / len(data)) * 100,
                "lower_bound": lower_bound,
                "upper_bound": upper_bound,
                "outlier_values": outliers.head(10).tolist()
            }
            
        except Exception:
            return {"count": 0, "percentage": 0, "error": "Could not detect outliers"}
    
    def _analyze_text_patterns(self, data: pd.Series) -> dict:
        """Analyze patterns in text data"""
        
        try:
            text_data = data.astype(str)
            
            patterns = {
                "contains_digits": text_data.str.contains(r'\d').sum(),
                "contains_uppercase": text_data.str.contains(r'[A-Z]').sum(),
                "contains_lowercase": text_data.str.contains(r'[a-z]').sum(),
                "contains_special_chars": text_data.str.contains(r'[^a-zA-Z0-9\s]').sum(),
                "starts_with_digit": text_data.str.match(r'^\d').sum(),
                "email_like": text_data.str.contains(r'\S+@\S+\.\S+').sum(),
                "url_like": text_data.str.contains(r'http[s]?://').sum(),
                "phone_like": text_data.str.contains(r'\d{3}[-.]?\d{3}[-.]?\d{4}').sum()
            }
            
            # Convert counts to percentages
            total = len(data)
            for key in patterns:
                patterns[f"{key}_percentage"] = (patterns[key] / total) * 100
            
            return patterns
            
        except Exception:
            return {"error": "Could not analyze text patterns"}
    
    def compare_datasets(self, data1: pd.DataFrame, data2: pd.DataFrame, 
                        output_path: Optional[str] = None) -> str:
        """Compare two datasets and generate comparison report"""
        
        try:
            # This would require extending ydata-profiling or creating custom comparison
            # For now, we'll create a basic comparison
            
            comparison_data = {
                "dataset_1": self.get_basic_statistics(data1),
                "dataset_2": self.get_basic_statistics(data2),
                "comparison": {
                    "shape_diff": {
                        "rows": data2.shape[0] - data1.shape[0],
                        "columns": data2.shape[1] - data1.shape[1]
                    },
                    "common_columns": list(set(data1.columns) & set(data2.columns)),
                    "unique_to_dataset_1": list(set(data1.columns) - set(data2.columns)),
                    "unique_to_dataset_2": list(set(data2.columns) - set(data1.columns))
                }
            }
            
            # Create simple HTML report for comparison
            if output_path is None:
                temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.html')
                output_path = temp_file.name
                temp_file.close()
            
            html_content = self._generate_comparison_html(comparison_data)
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Failed to compare datasets: {str(e)}")
    
    def _generate_comparison_html(self, comparison_data: dict) -> str:
        """Generate HTML content for dataset comparison"""
        
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Dataset Comparison Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                .section {{ margin: 30px 0; }}
                h1, h2 {{ color: #333; }}
            </style>
        </head>
        <body>
            <h1>Dataset Comparison Report</h1>
            
            <div class="section">
                <h2>Dataset Overview</h2>
                <table>
                    <tr><th>Metric</th><th>Dataset 1</th><th>Dataset 2</th><th>Difference</th></tr>
                    <tr><td>Rows</td><td>{comparison_data['dataset_1']['dataset_info']['n_rows']}</td><td>{comparison_data['dataset_2']['dataset_info']['n_rows']}</td><td>{comparison_data['comparison']['shape_diff']['rows']}</td></tr>
                    <tr><td>Columns</td><td>{comparison_data['dataset_1']['dataset_info']['n_columns']}</td><td>{comparison_data['dataset_2']['dataset_info']['n_columns']}</td><td>{comparison_data['comparison']['shape_diff']['columns']}</td></tr>
                    <tr><td>Missing Cells %</td><td>{comparison_data['dataset_1']['dataset_info']['missing_cells_perc']:.2f}%</td><td>{comparison_data['dataset_2']['dataset_info']['missing_cells_perc']:.2f}%</td><td>{comparison_data['dataset_2']['dataset_info']['missing_cells_perc'] - comparison_data['dataset_1']['dataset_info']['missing_cells_perc']:.2f}%</td></tr>
                </table>
            </div>
            
            <div class="section">
                <h2>Column Comparison</h2>
                <p><strong>Common Columns ({len(comparison_data['comparison']['common_columns'])}):</strong> {', '.join(comparison_data['comparison']['common_columns'])}</p>
                <p><strong>Unique to Dataset 1:</strong> {', '.join(comparison_data['comparison']['unique_to_dataset_1'])}</p>
                <p><strong>Unique to Dataset 2:</strong> {', '.join(comparison_data['comparison']['unique_to_dataset_2'])}</p>
            </div>
        </body>
        </html>
        """
        
        return html_template
